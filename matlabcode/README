Overview:
========

runanalysis.m is the top level file and is used to set up runs that
-- enumerate categories
-- enumerate partitions
-- score the complexity of partitions
-- score the cost of partitions
-- make the scatterplots in Figs 4, S3, and S9
-- make the SOM tables.

Some important parameters for these runs are set by setps.m.

The outer loop in runanalysis is specified by setting patterns, groups,
and stages. For example,

patterns = [100, 1,1, 1, 4,3,6,1,0];  
groups = {[14:19]};
rstages = {[5,6]};

will run analysis stages 5 and 6 (scoring complexity and cost) for trees
14 through 19 (the six subtrees in Fig 4C). The first element in patterns
(ie 100) is a dummy that will be replaced by the tree numbers 14 through
19. The remaining elements in patterns specify:

- ys, a triple that specifies the base predicates and primitives used to
  enumerate categories and the strategy for enumerating components. The
  triple here is [1,1,1], which indicates that the categories used are
  enumerated by starting with the standard set of primitives and allowing
  both disjunctive and conjunctive combinations.

    - ys(1) will be 1 for most analyses and 6 for the cousins analyses. 
    - ys(2) should be 1 in all cases because complexities
      are always computed with respect to the same set of primitives. 
    - ys(3) will be 1 for enumerations that include disjunctive
      combinations and 2 for enumerations that do not. 
      
- e, the strategy for enumerating partitions.  Here e = 4 which means that
  partitions are enumerated using dancinglinks then saved as a 
  matlab file.

- s, the strategy for computing partition complexity. Here s = 3 which
  means that the partition file will be split and the complexities of the
  pieces computed in parallel.

- v, the need probability vector. Here v = 6 which represents the standard
  set of need probabilities. v is set to 8 for the stable population
  analysis described in the SOM.

- the final two elements (here 1,0) are currently unused and are retained
  for backwards compatibility.

Note that the list of indices supported by the current release has gaps --
for example, the tree used in the main text is tree 12, and this release
does not include trees 1 through 11. Trees 1 through 11 include various
smaller subsets of tree 12 that were used when developing the code.
Although this release does not include trees 1 through 11, the original
labels for the trees are retained in this release for backwards
compatibility.

Settings to replicate the figures in the paper:
==============================================

Preparations for Fig 4:
=======================

(i) Generate the disjunctive set of categories by running:
patterns = [100, 1,1, 1, 3,3,6,1,0];  
groups = {[12]};  
rstages = {[3]};

(note that this takes between 48 and 72 hours)

(ii) Generate scores for attested partitions by running:
patterns = [100, 1,1, 1, 2,3,6,1,0];  
groups = {[12]};  
rstages = {[1,2,4,5,6]};

Figs 4A and 4B:
==============

Set 
ps.nsamplepartition	= 400000000; 
ps.nsearch		=     10000;      
ps.rheuristic		=         1;      

(i) Sample partitions from a space that allows disjunctive categories, 
score these partitions, and make a combined score file:

patterns = [100, 1,1, 1, 3,3,6,1,0];  
groups = {[12]};  
rstages = {[4,5,6,10]};

(NB: scoring the complexity of these partitions takes a long time --
perhaps a week or more.  scorecomplexity.m uses Matlab's parallel
computing toolbox to score partitions in parallel. To speed up the process
further I used scorecomplexity.m to create all the input files needed in
order to run the C program scorecomplexity, then invoked this program by
simultaneously running 

> make r1 -j 8 -f Makefile_12_1_1_9_3
> make r2 -j 8 -f Makefile_12_1_1_9_3
> make r3 -j 8 -f Makefile_12_1_1_9_3
 
from the command line on three separate 8-core machines. The same basic
approach was used for other long computations -- e.g. the computations
described in sections (ii) and (iii) below -- but the Makefiles for these
computations aren't included in this package).

(ii) Sample partitions from a space that allows conjunctive categories, 
score these partitions, and make a combined score file:

patterns = [100, 1,1, 9, 3,3,6,1,0];  
groups = {[12]};  
rstages = {[3,4,5,6,10]};

(iii) Enumerate and score all partitions constructed from attested categories
that appear twice or more:

patterns = [100, 1,1, 16, 5,3,6,1,0];  
groups = {[12]};  
rstages = {[3,4,5,6]};

(iv) Manually make the final combined score file by typing

cat combinedscores_12_1_1_1_3_6_rpt1_rand0
    combinedscores_12_1_1_9_3_6_rpt1_rand0 
    combinedscores_12_1_1_16_5_6_rpt1_rand0 >
    combinedscores_12_10_10_10_10_6_rpt1_rand0

at the system prompt in the output directory

(v) Make Figs 4A and 4B by running

patterns = [100, 10,10,  10, 10,10,6,1,0;
            100, 1,  1,  16, 5, 3,6,1,0];
groups = {[12],[12]};
rstages = {[8],[8]};

Fig 4C:
======

Set 
ps.nsearch		=     100000000;
ps.rheuristic		=	      2;

(i) Make categories for subtree analyses, generate files with attested
partitions, and score cost and complexity of these partitions: 

patterns = [100, 1,1, 1, 2,3,6,1,0];  
groups = {[14:19]};  
rstages = {[1,2,3,4,5,6]};

(ii) Enumerate partitions for each subtree, score cost and complexity of
these partitions, and generate combined score file:

patterns = [100, 1,1, 1, 4,3,6,1,0];  
groups = {[14:19]};  
rstages = {[4,5,6,10]};

(iii) Make panels for Fig 4C by running

patterns = [100, 1,1, 1, 4,3,6,1,0];
groups = {[14]};
rstages = {[8]};

Tables S1 through S6:
=====================

(run this after following the procedure to generate Fig 4)

patterns = [100, 1,1,  1,4,1,6,1,0];  
groups = {[14:19]};
rstages = {[7]};

This should generate files table_14 through table_19 in the output
directory that correspond to tables S1 through S6.

Fig S8:
======

(run this after following the procedure to generate Tables S1 through S6)

Type

> plotdomscores

at the Matlab prompt.

Preparations for Fig S9:
=======================

The procedure for generating Fig S9 is very similar to the procedure for
generating Fig 4.

(i) Generate the conjunctive set of categories by running:
patterns = [100, 1,1, 2, 3,3,6,1,0];  
groups = {[12]};  
rstages = {[3]};

(ii) Generate scores for attested partitions by running:
patterns = [100, 1,1, 2, 2,3,6,1,0];  
groups = {[12]};  
rstages = {[1,2,4,5,6]};

Figs S9A and S9B:
================

Set 
ps.nsamplepartition	= 400000000; 
ps.nsearch		=     10000;      
ps.rheuristic		=         1;      

(i) Sample partitions from a space that does not allow disjunctive categories, 
score these partitions, and make a combined score file:

patterns = [100, 1,1, 2, 3,3,6,1,0];  
groups = {[12]};  
rstages = {[4,5,6,10]};

(iii) Enumerate and score all partitions constructed from attested categories
that appear twice or more:

patterns = [100, 1,1, 18, 5,3,6,1,0];  
groups = {[12]};  
rstages = {[3,4,5,6]};

(iv) Manually make the final combined score file by typing

cat combinedscores_12_1_1_2_3_6_rpt1_rand0
    combinedscores_12_1_1_18_5_6_rpt1_rand0 >
    combinedscores_12_9_9_9_9_6_rpt1_rand0

at the system prompt in the output directory

(v) Make Figs S9A and S9B by running

patterns = [100, 9, 9, 9, 9, 9,6,1,0;
            100, 1, 1,18, 5, 3,6,1,0];
groups = {[12],[12]};
rstages = {[8],[8]};

Fig S9C:
======

Set 
ps.nsearch		=     100000000;
ps.rheuristic		=	      2;

(i) Make categories for subtree analyses, generate files with attested
partitions, and score cost and complexity of these partitions: 

patterns = [100, 1,1, 2, 2,3,6,1,0];  
groups = {[14:19]};  
rstages = {[1,2,3,4,5,6]};

(ii) Enumerate partitions for each subtree, score cost and complexity of
these partitions, and generate combined score file:

patterns = [100, 1,1, 2, 4,3,6,1,0];  
groups = {[14:19]};  
rstages = {[4,5,6,10]};

(iii) Make panels for Fig S9C by running

patterns = [100, 1,1, 2, 4,3,6,1,0];
groups = {[14]};
rstages = {[8]};

Fig S3:
=======

(i)  Make starter set of conjunctive categories: 

patterns = [100, 1,1, 2, 2,3,6,1,0];  
groups = {[13]};  
rstages = {[3]};

(ii) Build on starter set to create full set of cousins categories. Sample
and score partitions built from these categories.

Set 

ps.nsamplepartition = 100000000; 
ps.nsearch	    =     10000;      
ps.rheuristic       =	      1;      

patterns = [100, 6,1, 20, 3,3,6,1,0];  
groups = {[13]};  
rstages = {[3,4,5,6,10]};

(iii) Score attested partitions

patterns = [100, 6,1, 20, 2,3,6,1,0];  
groups = {[13]};  
rstages = {[1,2,4,5,6]};

(iv) Make Fig S3

patterns = [100, 6,1, 20, 3,3,6,1,0];  
groups = {[13]};  
rstages = {[8]};


Remaining figures:
=================

The instructions for generating the remaining figures are less complete.
In some cases you'll need to edit the Matlab scripts directly to specify
the locations of certain output files on your system.  Please email
Charles (ckemp@cmu.edu) if you are interested in generating these figures
and the instructions below aren't sufficient. 

Fig 5:
======

(i) Create permutation specification

Type
> cd permanalysis
> makeperms_nib
> makerwperms_nib
> makecompmap_nib

at the Matlab prompt to create permanalysis/systemperms_nib,
permanalysis/rwperms_nib, permanalysis/comppermmap_nib

(ii) 

Create and score permuted partitions

patterns = [100, 1,1,  1,11,3,6,1,0]; 
groups = {[12]};
rstages = {[4,5,6,11]};  

(iii) 

Type

> cd permanalysis
> readpermresults_nib
> plotpermresults_nib

at the Matlab prompt to generate panels for Figs 5B and 5C

(iv) 

Generate component file with real-world disjunctive components:

patterns = [100, 1,1,  7,3,3,6,1,0];
groups = {[12]};
rstages = {[3]};


Type 
> convsdisnib.m -- make sets of conjunctive, disjunctive, rw concepts
> viewconvsdis_withinchunknib.m -- scores for conj, disj
> plotconvsdisnib.m 

at the Matlab prompt to generate Fig 5D.

Fig S4:
=======

(i) Create permutation specification

Type
> cd permanalysis
> makeperms_cousin 
> makecompmap_cousin

at the Matlab prompt to create permanalysis/systemperms_cousin,
permanalysis/comppermmap_cousin

(ii) 

Set 
ps.nsearch	    = 100000000;      
ps.rheuristic       =	      1;      

Generate and score partitions by running

patterns = [100, 6,1,  20,14,3,6,1,0];  % enumerate cousins -- special
groups = {[13]};
rstages = {[4,5,6,11]};

(iii) 

Type
> cd permanalysis
> readpermresults_cousin
> plotpermresults_cousin

at the Matlab prompt to generate Fig S4B.

Fig S7:
=======

(i) 

First prepare 

  combinedscoreswithdup_12_1_1_16_5_6_rpt1_rand0
  combinedscoreswithdup_12_1_1_16_2_6_rpt1_rand0

(ii) 

Type 

> makerandanalysisfilenib
> randanalysispreparenib
> randanalysisnib

at the Matlab prompt.

(iii) 

Set 
ps.nsearch	    =     10000;      
ps.rheuristic       =	      1;      

patterns = [100, 1,1,7, 2,3,6,1,0];  
groups = {[12]};  
rstages = {[3,4,5]};

(iv)

Set paths in bootstrap/boottemplatenib.opt appropriately

Type 

> cd bootstrap
> shufflematnib
> checkboots

at the Matlab prompt.

(v) Type 

plotrandanalysisnib.m

to generate Fig S7

Known limitations:
==================

- When generating intensions, extensions, and ego-relative extensions, we
  remove intensions which generate the same extension as an alternative
  with lower weight. As mentioned in the SOM, this can mean that we remove
  intensions that are needed in order to achieve the minimal-complexity
  definition of some partitions. A more sophisticated algorithm for
  enumerating categories and scoring partitions may be able to overcome
  this limitation.

- Using one individual per kin type in Fig 2 means that the code accepts
  incorrect intensions for some categories. Consider the category that
  includes "any sibling except a younger sister". Given the tree in Fig 2,
  the ego-relative extension includes By, Ze, Be, and this extension can
  be captured by the intension "sibling of a younger sister." Note,
  however, that "sibling of a younger sister" is not equivalent to "any
  sibling except a younger sister"-- to see why, consider an individual
  with two younger sisters. This limitation could be overcome by including
  multiple representatives of all relevant kintypes (siblings, aunts,
  uncles, children, nieces and nephews, and grandchildren). Making this
  change, however, is difficult given the current setup because adding
  more individuals to the family tree increases the amount of memory
  required when enumerating categories. 

